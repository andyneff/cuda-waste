/** \file
 *  This C header file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : Ptx.g
 *     -                            On : 2010-11-14 06:50:06
 *     -                 for the lexer : PtxLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
 * The lexer PtxLexer has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 * 
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pPtxLexer, which is returned from a call to PtxLexerNew().
 *
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the methods are provided anyway.
 * * The methods in pPtxLexer are  as follows:
 *
 *  -  void      pPtxLexer->KI_ABS(pPtxLexer)
 *  -  void      pPtxLexer->KI_ADD(pPtxLexer)
 *  -  void      pPtxLexer->KI_ADDC(pPtxLexer)
 *  -  void      pPtxLexer->KI_AND(pPtxLexer)
 *  -  void      pPtxLexer->KI_ATOM(pPtxLexer)
 *  -  void      pPtxLexer->KI_BAR(pPtxLexer)
 *  -  void      pPtxLexer->KI_BFE(pPtxLexer)
 *  -  void      pPtxLexer->KI_BFI(pPtxLexer)
 *  -  void      pPtxLexer->KI_BFIND(pPtxLexer)
 *  -  void      pPtxLexer->KI_BRA(pPtxLexer)
 *  -  void      pPtxLexer->KI_BREV(pPtxLexer)
 *  -  void      pPtxLexer->KI_BRKPT(pPtxLexer)
 *  -  void      pPtxLexer->KI_CALL(pPtxLexer)
 *  -  void      pPtxLexer->KI_CLZ(pPtxLexer)
 *  -  void      pPtxLexer->KI_CNOT(pPtxLexer)
 *  -  void      pPtxLexer->KI_COPYSIGN(pPtxLexer)
 *  -  void      pPtxLexer->KI_COS(pPtxLexer)
 *  -  void      pPtxLexer->KI_CVT(pPtxLexer)
 *  -  void      pPtxLexer->KI_CVTA(pPtxLexer)
 *  -  void      pPtxLexer->KI_DIV(pPtxLexer)
 *  -  void      pPtxLexer->KI_EX2(pPtxLexer)
 *  -  void      pPtxLexer->KI_EXIT(pPtxLexer)
 *  -  void      pPtxLexer->KI_FMA(pPtxLexer)
 *  -  void      pPtxLexer->KI_ISSPACEP(pPtxLexer)
 *  -  void      pPtxLexer->KI_LD(pPtxLexer)
 *  -  void      pPtxLexer->KI_LDU(pPtxLexer)
 *  -  void      pPtxLexer->KI_LG2(pPtxLexer)
 *  -  void      pPtxLexer->KI_MAD24(pPtxLexer)
 *  -  void      pPtxLexer->KI_MAD(pPtxLexer)
 *  -  void      pPtxLexer->KI_MAX(pPtxLexer)
 *  -  void      pPtxLexer->KI_MEMBAR(pPtxLexer)
 *  -  void      pPtxLexer->KI_MIN(pPtxLexer)
 *  -  void      pPtxLexer->KI_MOV(pPtxLexer)
 *  -  void      pPtxLexer->KI_MUL24(pPtxLexer)
 *  -  void      pPtxLexer->KI_MUL(pPtxLexer)
 *  -  void      pPtxLexer->KI_NEG(pPtxLexer)
 *  -  void      pPtxLexer->KI_NOT(pPtxLexer)
 *  -  void      pPtxLexer->KI_OR(pPtxLexer)
 *  -  void      pPtxLexer->KI_PMEVENT(pPtxLexer)
 *  -  void      pPtxLexer->KI_POPC(pPtxLexer)
 *  -  void      pPtxLexer->KI_PREFETCH(pPtxLexer)
 *  -  void      pPtxLexer->KI_PREFETCHU(pPtxLexer)
 *  -  void      pPtxLexer->KI_PRMT(pPtxLexer)
 *  -  void      pPtxLexer->KI_RCP(pPtxLexer)
 *  -  void      pPtxLexer->KI_RED(pPtxLexer)
 *  -  void      pPtxLexer->KI_REM(pPtxLexer)
 *  -  void      pPtxLexer->KI_RET(pPtxLexer)
 *  -  void      pPtxLexer->KI_RSQRT(pPtxLexer)
 *  -  void      pPtxLexer->KI_SAD(pPtxLexer)
 *  -  void      pPtxLexer->KI_SELP(pPtxLexer)
 *  -  void      pPtxLexer->KI_SETP(pPtxLexer)
 *  -  void      pPtxLexer->KI_SET(pPtxLexer)
 *  -  void      pPtxLexer->KI_SHL(pPtxLexer)
 *  -  void      pPtxLexer->KI_SHR(pPtxLexer)
 *  -  void      pPtxLexer->KI_SIN(pPtxLexer)
 *  -  void      pPtxLexer->KI_SLCT(pPtxLexer)
 *  -  void      pPtxLexer->KI_SQRT(pPtxLexer)
 *  -  void      pPtxLexer->KI_ST(pPtxLexer)
 *  -  void      pPtxLexer->KI_SUB(pPtxLexer)
 *  -  void      pPtxLexer->KI_SUBC(pPtxLexer)
 *  -  void      pPtxLexer->KI_SULD(pPtxLexer)
 *  -  void      pPtxLexer->KI_SUQ(pPtxLexer)
 *  -  void      pPtxLexer->KI_SURED(pPtxLexer)
 *  -  void      pPtxLexer->KI_SUST(pPtxLexer)
 *  -  void      pPtxLexer->KI_TESTP(pPtxLexer)
 *  -  void      pPtxLexer->KI_TEX(pPtxLexer)
 *  -  void      pPtxLexer->KI_TRAP(pPtxLexer)
 *  -  void      pPtxLexer->KI_TXQ(pPtxLexer)
 *  -  void      pPtxLexer->KI_VABSDIFF(pPtxLexer)
 *  -  void      pPtxLexer->KI_VADD(pPtxLexer)
 *  -  void      pPtxLexer->KI_VMAD(pPtxLexer)
 *  -  void      pPtxLexer->KI_VMAX(pPtxLexer)
 *  -  void      pPtxLexer->KI_VMIN(pPtxLexer)
 *  -  void      pPtxLexer->KI_VOTE(pPtxLexer)
 *  -  void      pPtxLexer->KI_VSET(pPtxLexer)
 *  -  void      pPtxLexer->KI_VSHL(pPtxLexer)
 *  -  void      pPtxLexer->KI_VSHR(pPtxLexer)
 *  -  void      pPtxLexer->KI_VSUB(pPtxLexer)
 *  -  void      pPtxLexer->KI_XOR(pPtxLexer)
 *  -  void      pPtxLexer->T_QUESTION(pPtxLexer)
 *  -  void      pPtxLexer->T_OROR(pPtxLexer)
 *  -  void      pPtxLexer->T_ANDAND(pPtxLexer)
 *  -  void      pPtxLexer->T_OR(pPtxLexer)
 *  -  void      pPtxLexer->T_XOR(pPtxLexer)
 *  -  void      pPtxLexer->T_AND(pPtxLexer)
 *  -  void      pPtxLexer->T_EQEQ(pPtxLexer)
 *  -  void      pPtxLexer->T_LE(pPtxLexer)
 *  -  void      pPtxLexer->T_GE(pPtxLexer)
 *  -  void      pPtxLexer->T_LTLT(pPtxLexer)
 *  -  void      pPtxLexer->T_GTGT(pPtxLexer)
 *  -  void      pPtxLexer->T_STAR(pPtxLexer)
 *  -  void      pPtxLexer->T_TILDE(pPtxLexer)
 *  -  void      pPtxLexer->T_FLT_LITERAL(pPtxLexer)
 *  -  void      pPtxLexer->T_HEX_LITERAL(pPtxLexer)
 *  -  void      pPtxLexer->T_OCT_LITERAL(pPtxLexer)
 *  -  void      pPtxLexer->T_DEC_LITERAL(pPtxLexer)
 *  -  void      pPtxLexer->K_3D(pPtxLexer)
 *  -  void      pPtxLexer->K_2D(pPtxLexer)
 *  -  void      pPtxLexer->K_1D(pPtxLexer)
 *  -  void      pPtxLexer->U_DEBUG_PUBNAMES(pPtxLexer)
 *  -  void      pPtxLexer->U_DEBUG_LINE(pPtxLexer)
 *  -  void      pPtxLexer->U_DEBUG_INFO(pPtxLexer)
 *  -  void      pPtxLexer->U_DEBUG_ABBREV(pPtxLexer)
 *  -  void      pPtxLexer->U_BYTE(pPtxLexer)
 *  -  void      pPtxLexer->U_4BYTE(pPtxLexer)
 *  -  void      pPtxLexer->T_EQ(pPtxLexer)
 *  -  void      pPtxLexer->T_SEMICOLON(pPtxLexer)
 *  -  void      pPtxLexer->T_PLUS(pPtxLexer)
 *  -  void      pPtxLexer->T_OP(pPtxLexer)
 *  -  void      pPtxLexer->T_OC(pPtxLexer)
 *  -  void      pPtxLexer->T_OB(pPtxLexer)
 *  -  void      pPtxLexer->T_NOTEQ(pPtxLexer)
 *  -  void      pPtxLexer->T_NOT(pPtxLexer)
 *  -  void      pPtxLexer->T_MINUS(pPtxLexer)
 *  -  void      pPtxLexer->T_GT(pPtxLexer)
 *  -  void      pPtxLexer->T_LT(pPtxLexer)
 *  -  void      pPtxLexer->T_ELLIPSIS(pPtxLexer)
 *  -  void      pPtxLexer->T_CP(pPtxLexer)
 *  -  void      pPtxLexer->T_COMMA(pPtxLexer)
 *  -  void      pPtxLexer->T_COLON(pPtxLexer)
 *  -  void      pPtxLexer->T_CC(pPtxLexer)
 *  -  void      pPtxLexer->T_CB(pPtxLexer)
 *  -  void      pPtxLexer->LINE_COMMENT(pPtxLexer)
 *  -  void      pPtxLexer->K_ZERO(pPtxLexer)
 *  -  void      pPtxLexer->K_XOR(pPtxLexer)
 *  -  void      pPtxLexer->K_WT(pPtxLexer)
 *  -  void      pPtxLexer->K_WIDTH(pPtxLexer)
 *  -  void      pPtxLexer->K_WIDE(pPtxLexer)
 *  -  void      pPtxLexer->K_WB(pPtxLexer)
 *  -  void      pPtxLexer->K_VOLATILE(pPtxLexer)
 *  -  void      pPtxLexer->K_VISIBLE(pPtxLexer)
 *  -  void      pPtxLexer->K_VERSION(pPtxLexer)
 *  -  void      pPtxLexer->K_VB(pPtxLexer)
 *  -  void      pPtxLexer->K_V4(pPtxLexer)
 *  -  void      pPtxLexer->K_V2(pPtxLexer)
 *  -  void      pPtxLexer->K_UNI(pPtxLexer)
 *  -  void      pPtxLexer->K_U8(pPtxLexer)
 *  -  void      pPtxLexer->K_U64(pPtxLexer)
 *  -  void      pPtxLexer->K_U32(pPtxLexer)
 *  -  void      pPtxLexer->K_U16(pPtxLexer)
 *  -  void      pPtxLexer->K_TRAP(pPtxLexer)
 *  -  void      pPtxLexer->K_TO(pPtxLexer)
 *  -  void      pPtxLexer->K_TEXREF(pPtxLexer)
 *  -  void      pPtxLexer->K_TEX(pPtxLexer)
 *  -  void      pPtxLexer->K_TARGET(pPtxLexer)
 *  -  void      pPtxLexer->K_SYS(pPtxLexer)
 *  -  void      pPtxLexer->K_SYNC(pPtxLexer)
 *  -  void      pPtxLexer->K_SURFREF(pPtxLexer)
 *  -  void      pPtxLexer->K_SUBNORMAL(pPtxLexer)
 *  -  void      pPtxLexer->K_SREG(pPtxLexer)
 *  -  void      pPtxLexer->K_SHIFTAMT(pPtxLexer)
 *  -  void      pPtxLexer->K_SHARED(pPtxLexer)
 *  -  void      pPtxLexer->K_SECTION(pPtxLexer)
 *  -  void      pPtxLexer->K_SAT(pPtxLexer)
 *  -  void      pPtxLexer->K_SAMPLERREF(pPtxLexer)
 *  -  void      pPtxLexer->K_S8(pPtxLexer)
 *  -  void      pPtxLexer->K_S64(pPtxLexer)
 *  -  void      pPtxLexer->K_S32(pPtxLexer)
 *  -  void      pPtxLexer->K_S16(pPtxLexer)
 *  -  void      pPtxLexer->K_RZI(pPtxLexer)
 *  -  void      pPtxLexer->K_RZ(pPtxLexer)
 *  -  void      pPtxLexer->K_RPI(pPtxLexer)
 *  -  void      pPtxLexer->K_RP(pPtxLexer)
 *  -  void      pPtxLexer->K_RNI(pPtxLexer)
 *  -  void      pPtxLexer->K_RN(pPtxLexer)
 *  -  void      pPtxLexer->K_RMI(pPtxLexer)
 *  -  void      pPtxLexer->K_RM(pPtxLexer)
 *  -  void      pPtxLexer->K_REQNTID(pPtxLexer)
 *  -  void      pPtxLexer->K_REG(pPtxLexer)
 *  -  void      pPtxLexer->K_RED(pPtxLexer)
 *  -  void      pPtxLexer->K_RCP(pPtxLexer)
 *  -  void      pPtxLexer->K_RC8(pPtxLexer)
 *  -  void      pPtxLexer->K_RC16(pPtxLexer)
 *  -  void      pPtxLexer->K_PRED(pPtxLexer)
 *  -  void      pPtxLexer->K_PRAGMA(pPtxLexer)
 *  -  void      pPtxLexer->K_POPC(pPtxLexer)
 *  -  void      pPtxLexer->K_PARAM(pPtxLexer)
 *  -  void      pPtxLexer->K_P(pPtxLexer)
 *  -  void      pPtxLexer->K_OR(pPtxLexer)
 *  -  void      pPtxLexer->K_OC(pPtxLexer)
 *  -  void      pPtxLexer->K_NUMBER(pPtxLexer)
 *  -  void      pPtxLexer->K_NUM(pPtxLexer)
 *  -  void      pPtxLexer->K_NS(pPtxLexer)
 *  -  void      pPtxLexer->K_NOUNROLL(pPtxLexer)
 *  -  void      pPtxLexer->T_STRING(pPtxLexer)
 *  -  void      pPtxLexer->K_NOTANUMBER(pPtxLexer)
 *  -  void      pPtxLexer->K_NORMALIZED_COORDS(pPtxLexer)
 *  -  void      pPtxLexer->K_NORMAL(pPtxLexer)
 *  -  void      pPtxLexer->K_NEU(pPtxLexer)
 *  -  void      pPtxLexer->K_NE(pPtxLexer)
 *  -  void      pPtxLexer->K_NAN(pPtxLexer)
 *  -  void      pPtxLexer->K_MINNCTAPERSM(pPtxLexer)
 *  -  void      pPtxLexer->K_MIN(pPtxLexer)
 *  -  void      pPtxLexer->K_MAXNTID(pPtxLexer)
 *  -  void      pPtxLexer->K_MAXNREG(pPtxLexer)
 *  -  void      pPtxLexer->K_MAXNCTAPERSM(pPtxLexer)
 *  -  void      pPtxLexer->K_MAX(pPtxLexer)
 *  -  void      pPtxLexer->K_LU(pPtxLexer)
 *  -  void      pPtxLexer->K_LTU(pPtxLexer)
 *  -  void      pPtxLexer->K_LT(pPtxLexer)
 *  -  void      pPtxLexer->K_LS(pPtxLexer)
 *  -  void      pPtxLexer->K_LOCAL(pPtxLexer)
 *  -  void      pPtxLexer->K_LOC(pPtxLexer)
 *  -  void      pPtxLexer->K_LO(pPtxLexer)
 *  -  void      pPtxLexer->K_LEU(pPtxLexer)
 *  -  void      pPtxLexer->K_LE(pPtxLexer)
 *  -  void      pPtxLexer->K_L2(pPtxLexer)
 *  -  void      pPtxLexer->K_L1(pPtxLexer)
 *  -  void      pPtxLexer->K_INFINITE(pPtxLexer)
 *  -  void      pPtxLexer->K_INC(pPtxLexer)
 *  -  void      pPtxLexer->K_HS(pPtxLexer)
 *  -  void      pPtxLexer->K_HI(pPtxLexer)
 *  -  void      pPtxLexer->K_HEIGHT(pPtxLexer)
 *  -  void      pPtxLexer->K_GTU(pPtxLexer)
 *  -  void      pPtxLexer->K_GT(pPtxLexer)
 *  -  void      pPtxLexer->K_GLOBAL(pPtxLexer)
 *  -  void      pPtxLexer->K_GL(pPtxLexer)
 *  -  void      pPtxLexer->K_GEU(pPtxLexer)
 *  -  void      pPtxLexer->K_GE(pPtxLexer)
 *  -  void      pPtxLexer->K_FUNC(pPtxLexer)
 *  -  void      pPtxLexer->K_FULL(pPtxLexer)
 *  -  void      pPtxLexer->K_FTZ(pPtxLexer)
 *  -  void      pPtxLexer->K_FINITE(pPtxLexer)
 *  -  void      pPtxLexer->K_FILTER_MODE(pPtxLexer)
 *  -  void      pPtxLexer->K_FILE(pPtxLexer)
 *  -  void      pPtxLexer->K_F64(pPtxLexer)
 *  -  void      pPtxLexer->K_F4E(pPtxLexer)
 *  -  void      pPtxLexer->K_F32(pPtxLexer)
 *  -  void      pPtxLexer->K_F16(pPtxLexer)
 *  -  void      pPtxLexer->K_EXTERN(pPtxLexer)
 *  -  void      pPtxLexer->K_EXCH(pPtxLexer)
 *  -  void      pPtxLexer->K_EQU(pPtxLexer)
 *  -  void      pPtxLexer->K_EQ(pPtxLexer)
 *  -  void      pPtxLexer->K_ENTRY(pPtxLexer)
 *  -  void      pPtxLexer->K_ECR(pPtxLexer)
 *  -  void      pPtxLexer->K_ECL(pPtxLexer)
 *  -  void      pPtxLexer->K_DWARF(pPtxLexer)
 *  -  void      pPtxLexer->K_DEPTH(pPtxLexer)
 *  -  void      pPtxLexer->K_DEC(pPtxLexer)
 *  -  void      pPtxLexer->K_CV(pPtxLexer)
 *  -  void      pPtxLexer->K_CTA(pPtxLexer)
 *  -  void      pPtxLexer->K_CS(pPtxLexer)
 *  -  void      pPtxLexer->K_CONST(pPtxLexer)
 *  -  void      pPtxLexer->K_CLAMP(pPtxLexer)
 *  -  void      pPtxLexer->K_CHANNEL_ORDER(pPtxLexer)
 *  -  void      pPtxLexer->K_CHANNEL_DATA_TYPE(pPtxLexer)
 *  -  void      pPtxLexer->K_CHANNEL_DATA(pPtxLexer)
 *  -  void      pPtxLexer->K_CG(pPtxLexer)
 *  -  void      pPtxLexer->K_CC(pPtxLexer)
 *  -  void      pPtxLexer->K_CAS(pPtxLexer)
 *  -  void      pPtxLexer->K_CALLTARGETS(pPtxLexer)
 *  -  void      pPtxLexer->K_CALLPROTOTYPE(pPtxLexer)
 *  -  void      pPtxLexer->K_CA(pPtxLexer)
 *  -  void      pPtxLexer->K_BRANCHTARGETS(pPtxLexer)
 *  -  void      pPtxLexer->K_BALLOT(pPtxLexer)
 *  -  void      pPtxLexer->K_B8(pPtxLexer)
 *  -  void      pPtxLexer->K_B64(pPtxLexer)
 *  -  void      pPtxLexer->K_B4E(pPtxLexer)
 *  -  void      pPtxLexer->K_B32(pPtxLexer)
 *  -  void      pPtxLexer->K_B16(pPtxLexer)
 *  -  void      pPtxLexer->K_ARRIVE(pPtxLexer)
 *  -  void      pPtxLexer->K_APPROX(pPtxLexer)
 *  -  void      pPtxLexer->K_ANY(pPtxLexer)
 *  -  void      pPtxLexer->K_AND(pPtxLexer)
 *  -  void      pPtxLexer->K_ALL(pPtxLexer)
 *  -  void      pPtxLexer->K_ALIGN(pPtxLexer)
 *  -  void      pPtxLexer->K_ADDR_MODE_2(pPtxLexer)
 *  -  void      pPtxLexer->K_ADDR_MODE_1(pPtxLexer)
 *  -  void      pPtxLexer->K_ADDR_MODE_0(pPtxLexer)
 *  -  void      pPtxLexer->K_ADD(pPtxLexer)
 *  -  void      pPtxLexer->K_X(pPtxLexer)
 *  -  void      pPtxLexer->K_Y(pPtxLexer)
 *  -  void      pPtxLexer->K_Z(pPtxLexer)
 *  -  void      pPtxLexer->K_W(pPtxLexer)
 *  -  void      pPtxLexer->K_A(pPtxLexer)
 *  -  void      pPtxLexer->K_R(pPtxLexer)
 *  -  void      pPtxLexer->K_G(pPtxLexer)
 *  -  void      pPtxLexer->K_B(pPtxLexer)
 *  -  void      pPtxLexer->COMMENT(pPtxLexer)
 *  -  void      pPtxLexer->WS(pPtxLexer)
 *  -  void      pPtxLexer->T_WORD(pPtxLexer)
 *  -  void      pPtxLexer->T_UNDERSCORE(pPtxLexer)
 *  -  void      pPtxLexer->T_AT(pPtxLexer)
 *  -  void      pPtxLexer->T_PERCENT(pPtxLexer)
 *  -  void      pPtxLexer->T_SLASH(pPtxLexer)
 *  -  void      pPtxLexer->T_DOT(pPtxLexer)
 *  -  void      pPtxLexer->EscapeSequence(pPtxLexer)
 *  -  void      pPtxLexer->OctalEscape(pPtxLexer)
 *  -  void      pPtxLexer->FollowSym(pPtxLexer)
 *  -  void      pPtxLexer->Tokens(pPtxLexer)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_PtxLexer_H
#define _PtxLexer_H
/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    <antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */
 
#ifdef __cplusplus
extern "C" {
#endif

// Forward declare the context typedef so that we can use it before it is
// properly defined. Delegators and delegates (from import statements) are
// interdependent and their context structures contain pointers to each other
// C only allows such things to be declared if you pre-declare the typedef.
//
typedef struct PtxLexer_Ctx_struct PtxLexer, * pPtxLexer;



#ifdef	ANTLR3_WINDOWS
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule 
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif

/* ========================
 * BACKTRACKING IS ENABLED
 * ========================
 */

/** Context tracking structure for PtxLexer
 */
struct PtxLexer_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
    pANTLR3_LEXER    pLexer;


     void (*mKI_ABS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_ADD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_ADDC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_AND)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_ATOM)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_BAR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_BFE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_BFI)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_BFIND)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_BRA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_BREV)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_BRKPT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_CALL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_CLZ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_CNOT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_COPYSIGN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_COS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_CVT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_CVTA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_DIV)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_EX2)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_EXIT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_FMA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_ISSPACEP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_LD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_LDU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_LG2)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MAD24)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MAD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MAX)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MEMBAR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MIN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MOV)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MUL24)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_MUL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_NEG)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_NOT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_OR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_PMEVENT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_POPC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_PREFETCH)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_PREFETCHU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_PRMT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_RCP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_RED)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_REM)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_RET)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_RSQRT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SAD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SELP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SETP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SET)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SHL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SHR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SIN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SLCT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SQRT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_ST)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SUB)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SUBC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SULD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SUQ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SURED)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_SUST)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_TESTP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_TEX)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_TRAP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_TXQ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VABSDIFF)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VADD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VMAD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VMAX)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VMIN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VOTE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VSET)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VSHL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VSHR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_VSUB)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mKI_XOR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_QUESTION)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_OROR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_ANDAND)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_OR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_XOR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_AND)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_EQEQ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_LE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_GE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_LTLT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_GTGT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_STAR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_TILDE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_FLT_LITERAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_HEX_LITERAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_OCT_LITERAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_DEC_LITERAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_3D)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_2D)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_1D)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mU_DEBUG_PUBNAMES)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mU_DEBUG_LINE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mU_DEBUG_INFO)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mU_DEBUG_ABBREV)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mU_BYTE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mU_4BYTE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_EQ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_SEMICOLON)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_PLUS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_OP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_OC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_OB)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_NOTEQ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_NOT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_MINUS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_GT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_LT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_ELLIPSIS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_CP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_COMMA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_COLON)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_CC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_CB)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mLINE_COMMENT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ZERO)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_XOR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_WT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_WIDTH)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_WIDE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_WB)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_VOLATILE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_VISIBLE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_VERSION)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_VB)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_V4)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_V2)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_UNI)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_U8)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_U64)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_U32)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_U16)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_TRAP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_TO)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_TEXREF)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_TEX)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_TARGET)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SYS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SYNC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SURFREF)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SUBNORMAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SREG)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SHIFTAMT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SHARED)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SECTION)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SAT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_SAMPLERREF)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_S8)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_S64)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_S32)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_S16)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RZI)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RZ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RPI)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RNI)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RMI)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RM)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_REQNTID)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_REG)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RED)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RCP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RC8)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_RC16)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_PRED)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_PRAGMA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_POPC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_PARAM)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_P)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_OR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_OC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NUMBER)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NUM)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NOUNROLL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_STRING)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NOTANUMBER)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NORMALIZED_COORDS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NORMAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NEU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_NAN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_MINNCTAPERSM)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_MIN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_MAXNTID)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_MAXNREG)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_MAXNCTAPERSM)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_MAX)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LTU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LOCAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LOC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LO)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LEU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_LE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_L2)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_L1)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_INFINITE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_INC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_HS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_HI)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_HEIGHT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_GTU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_GT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_GLOBAL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_GL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_GEU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_GE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_FUNC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_FULL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_FTZ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_FINITE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_FILTER_MODE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_FILE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_F64)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_F4E)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_F32)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_F16)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_EXTERN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_EXCH)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_EQU)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_EQ)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ENTRY)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ECR)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ECL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_DWARF)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_DEPTH)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_DEC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CV)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CTA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CONST)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CLAMP)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CHANNEL_ORDER)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CHANNEL_DATA_TYPE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CHANNEL_DATA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CG)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CC)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CAS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CALLTARGETS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CALLPROTOTYPE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_CA)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_BRANCHTARGETS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_BALLOT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_B8)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_B64)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_B4E)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_B32)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_B16)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ARRIVE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_APPROX)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ANY)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_AND)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ALL)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ALIGN)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ADDR_MODE_2)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ADDR_MODE_1)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ADDR_MODE_0)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_ADD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_X)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_Y)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_Z)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_W)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_A)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_R)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_G)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mK_B)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mCOMMENT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mWS)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_WORD)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_UNDERSCORE)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_AT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_PERCENT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_SLASH)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mT_DOT)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mEscapeSequence)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mOctalEscape)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mFollowSym)	(struct PtxLexer_Ctx_struct * ctx);
     void (*mTokens)	(struct PtxLexer_Ctx_struct * ctx);    const char * (*getGrammarFileName)();
    void	    (*free)   (struct PtxLexer_Ctx_struct * ctx);
        
};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//
ANTLR3_API pPtxLexer PtxLexerNew         (pANTLR3_INPUT_STREAM instream);
ANTLR3_API pPtxLexer PtxLexerNewSSD      (pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state);

/** Symbolic definitions of all the tokens that the lexer will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
#ifdef	Tokens
#undef	Tokens
#endif 
#define K_INFINITE      151
#define T_GE      256
#define KI_BAR      10
#define K_F64      133
#define KI_PREFETCHU      46
#define U_DEBUG_PUBNAMES      288
#define KI_CVTA      23
#define K_U32      221
#define K_ADDR_MODE_2      91
#define KI_LG2      31
#define K_CLAMP      115
#define K_GE      141
#define T_STAR      277
#define T_GT      257
#define K_PRED      185
#define TREE_PARAM_LIST      303
#define K_DEC      120
#define KI_SHL      57
#define K_ADDR_MODE_0      89
#define EOF      -1
#define K_ADDR_MODE_1      90
#define T_PERCENT      272
#define T_AND      242
#define KI_CVT      22
#define K_GL      143
#define TREE_PERF      305
#define K_RC8      188
#define KI_SHR      58
#define K_MINNCTAPERSM      168
#define K_GT      145
#define K_CALLTARGETS      108
#define KI_BRA      14
#define K_ADD      88
#define TREE_ENTRY      299
#define K_HI      148
#define K_ECR      124
#define K_WT      235
#define KI_AND      8
#define T_OROR      271
#define K_SAT      206
#define K_HS      149
#define K_VB      227
#define KI_LD      29
#define K_FUNC      139
#define K_SHARED      208
#define K_PRAGMA      184
#define K_SYNC      213
#define KI_DIV      24
#define K_NUMBER      178
#define KI_VSHR      81
#define KI_COPYSIGN      20
#define K_CHANNEL_ORDER      114
#define K_RED      190
#define K_WIDE      233
#define K_NEU      171
#define KI_VSHL      80
#define KI_CALL      17
#define KI_MIN      36
#define K_U64      222
#define K_WB      232
#define K_LTU      161
#define KI_CNOT      19
#define K_RCP      189
#define K_LOCAL      158
#define WS      289
#define K_EQ      126
#define T_SLASH      276
#define KI_SIN      59
#define KI_SURED      67
#define K_V4      226
#define FollowSym      314
#define T_LTLT      262
#define K_V2      225
#define KI_VMIN      77
#define K_SREG      210
#define T_MINUS      263
#define K_DWARF      122
#define K_MAXNREG      165
#define K_FULL      138
#define T_CB      245
#define KI_BREV      15
#define K_TEXREF      217
#define T_CC      246
#define T_UNDERSCORE      280
#define U_4BYTE      283
#define K_L2      153
#define TREE_ALIGN      308
#define K_L1      152
#define TREE_INST      294
#define KI_TRAP      71
#define KI_ADDC      7
#define T_CP      249
#define K_LOC      157
#define TREE_LABEL      293
#define K_REG      191
#define K_LE      154
#define K_F32      131
#define KI_MUL      39
#define T_GTGT      258
#define K_SECTION      207
#define K_EQU      127
#define T_ELLIPSIS      252
#define K_BALLOT      104
#define K_LS      159
#define K_LU      162
#define K_LT      160
#define KI_VSUB      82
#define KI_VADD      74
#define TREE_EXTERN      313
#define K_XOR      237
#define K_LO      156
#define KI_ABS      5
#define K_ECL      123
#define K_MAX      163
#define KI_NEG      40
#define KI_SULD      65
#define K_DEPTH      121
#define K_U16      220
#define KI_LDU      30
#define T_EQ      253
#define K_REQNTID      192
#define K_TRAP      219
#define K_CALLPROTOTYPE      107
#define KI_SETP      56
#define KI_RET      51
#define K_NAN      169
#define T_XOR      282
#define KI_REM      50
#define KI_VOTE      78
#define K_CAS      109
#define TREE_SPACE      301
#define K_SUBNORMAL      211
#define KI_XOR      83
#define K_MAXNTID      166
#define KI_RED      49
#define K_EXTERN      129
#define K_RC16      187
#define K_RZI      200
#define K_CHANNEL_DATA_TYPE      113
#define KI_COS      21
#define KI_ATOM      9
#define KI_MUL24      38
#define K_CTA      118
#define K_PARAM      182
#define OctalEscape      315
#define K_SURFREF      212
#define K_APPROX      96
#define K_MAXNCTAPERSM      164
#define T_ANDAND      243
#define KI_BFIND      13
#define KI_VSET      79
#define K_F4E      132
#define U_DEBUG_INFO      286
#define KI_POPC      44
#define T_STRING      278
#define K_SYS      214
#define KI_VMAD      75
#define K_GEU      142
#define TREE_ARRAY      306
#define KI_FMA      27
#define T_OP      269
#define T_OR      270
#define K_INC      150
#define KI_RCP      48
#define K_BRANCHTARGETS      105
#define K_OR      180
#define T_OB      266
#define KI_SLCT      60
#define T_OC      267
#define KI_SUBC      64
#define T_DOT      251
#define T_AT      244
#define K_B4E      100
#define K_HEIGHT      147
#define U_DEBUG_ABBREV      285
#define K_VISIBLE      229
#define KI_SQRT      61
#define COMMENT      4
#define TREE_VAR      300
#define K_ZERO      240
#define KI_VMAX      76
#define K_OC      179
#define K_ALL      93
#define K_A      87
#define K_SAMPLERREF      205
#define K_B      103
#define K_RMI      194
#define KI_SAD      53
#define K_B16      98
#define LINE_COMMENT      241
#define K_NOUNROLL      175
#define K_FILE      134
#define K_NS      176
#define T_OCT_LITERAL      268
#define K_P      181
#define KI_MAD      33
#define K_R      186
#define KI_ADD      6
#define KI_TESTP      69
#define T_TILDE      279
#define K_NE      170
#define K_B32      99
#define T_QUESTION      274
#define KI_CLZ      18
#define T_EQEQ      254
#define KI_ST      62
#define KI_VABSDIFF      73
#define K_WIDTH      234
#define K_G      140
#define T_SEMICOLON      275
#define KI_MOV      37
#define TREE_CONSTANT_EXPR      312
#define K_Z      239
#define K_VOLATILE      230
#define K_Y      238
#define K_X      236
#define U_DEBUG_LINE      287
#define TREE_TYPE      291
#define K_W      231
#define T_FLT_LITERAL      255
#define K_ANY      95
#define TREE_DEBUG      296
#define K_F16      130
#define K_ENTRY      125
#define KI_NOT      41
#define T_COMMA      248
#define TREE_OPR      290
#define K_AND      94
#define KI_PMEVENT      43
#define K_ALIGN      92
#define K_ARRIVE      97
#define EscapeSequence      316
#define K_GTU      146
#define K_FTZ      137
#define TREE_VECTOR_TYPE      302
#define KI_EX2      25
#define KI_MAX      34
#define K_CHANNEL_DATA      112
#define K_CG      111
#define KI_MEMBAR      35
#define T_WORD      281
#define KI_SUB      63
#define T_DEC_LITERAL      250
#define KI_BFI      12
#define K_U8      223
#define KI_ISSPACEP      28
#define K_CA      106
#define KI_BFE      11
#define K_CC      110
#define K_TEX      216
#define K_TO      218
#define TREE_BLOCK      295
#define K_1D      84
#define K_UNI      224
#define K_NOTANUMBER      174
#define KI_TXQ      72
#define K_TARGET      215
#define K_CONST      116
#define K_POPC      183
#define T_HEX_LITERAL      259
#define K_S64      203
#define T_COLON      247
#define K_LEU      155
#define KI_EXIT      26
#define K_RNI      196
#define U_BYTE      284
#define TREE_PARAM      304
#define T_PLUS      273
#define K_NUM      177
#define TREE_IRND      309
#define TREE_PRED      297
#define K_NORMAL      172
#define K_CV      119
#define K_CS      117
#define K_NORMALIZED_COORDS      173
#define KI_PREFETCH      45
#define K_S8      204
#define K_FINITE      136
#define K_VERSION      228
#define TREE_FRND      310
#define K_RZ      199
#define K_RP      197
#define K_FILTER_MODE      135
#define KI_BRKPT      16
#define K_RN      195
#define TREE_CAST      311
#define K_S32      202
#define KI_OR      42
#define K_MIN      167
#define K_3D      86
#define K_RM      193
#define K_GLOBAL      144
#define K_SHIFTAMT      209
#define K_EXCH      128
#define KI_PRMT      47
#define KI_SUST      68
#define TREE_EMPTY      292
#define T_LT      261
#define K_RPI      198
#define TREE_PAR_REGISTER      307
#define KI_RSQRT      52
#define K_B64      101
#define KI_TEX      70
#define K_2D      85
#define T_LE      260
#define KI_SUQ      66
#define K_B8      102
#define T_NOTEQ      265
#define K_S16      201
#define T_NOT      264
#define KI_SELP      54
#define KI_SET      55
#define KI_MAD24      32
#define TREE_FUNC      298
#ifdef	EOF
#undef	EOF
#define	EOF	ANTLR3_TOKEN_EOF
#endif

#ifndef TOKENSOURCE
#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource
#endif

/* End of token definitions for PtxLexer
 * =============================================================================
 */
/** \} */

#ifdef __cplusplus
}
#endif

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
