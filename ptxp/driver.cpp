
#include <stdio.h>
#include <iostream>
#include "PtxLexer.h"
#include "PtxParser.h"

static void print(pANTLR3_BASE_TREE node, int level)
{
	for (int i = 0; i < level; ++i)
	    printf("   ");
	printf("%s\n", node->getText(node)->chars);
	for (int i = 0; i < node->getChildCount(node); ++i)
	{
	    pANTLR3_BASE_TREE child = (pANTLR3_BASE_TREE)node->getChild(node, i);
	    print(child, level+1);
	}
} 

pANTLR3_BASE_TREE parse(char * ptx_module)
{
	pANTLR3_INPUT_STREAM       input;
	pPtxLexer             lxr;
	pANTLR3_COMMON_TOKEN_STREAM        tstream;
	pPtxParser                psr;
	PtxParser_prog_return     langAST;
	pANTLR3_COMMON_TREE_NODE_STREAM    nodes;
	//pPtx          treePsr;

	input  = antlr3NewAsciiStringInPlaceStream((pANTLR3_UINT8)ptx_module, strlen(ptx_module), 0);
	if ( input == NULL )
	{
		ANTLR3_FPRINTF(stderr, "Unable to read from string PTX module.\n");
	}
	else {
	}
	lxr        = PtxLexerNew(input);
	if ( lxr == NULL )
	{
		ANTLR3_FPRINTF(stderr, "Unable to create the lexer due to malloc() failure1\n");
		return 0;
	}
	tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
	if (tstream == NULL)
	{
		ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate token stream\n");
		return 0;
	}
	psr        = PtxParserNew(tstream);  // CParserNew is generated by ANTLR3
	if (psr == NULL)
	{
		ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate parser\n");
		return 0;
	}
	langAST = psr->prog(psr);
	if (psr->pParser->rec->getNumberOfSyntaxErrors(psr->pParser->rec) > 0)
	{
		ANTLR3_FPRINTF(stderr, "The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->getNumberOfSyntaxErrors);
	}
	else
	{
		// Dump tree.
		pANTLR3_BASE_TREE tree = langAST.tree;
		print(tree, 0);

//		nodes   = antlr3CommonTreeNodeStreamNewTree(langAST.tree, ANTLR3_SIZE_HINT); // sIZE HINT WILL SOON BE DEPRECATED!!

		// Tree parsers are given a common tree node stream (or your override)
		//
//		treePsr = LangDumpDeclNew(nodes);
//		treePsr->decl(treePsr);
//		nodes   ->free  (nodes);        nodes   = NULL;
		// treePsr ->free  (treePsr);      treePsr = NULL;
		return tree;
	}
 
		//psr     ->free  (psr);      psr     = NULL;
		//tstream ->free  (tstream);  tstream = NULL;
		//lxr     ->free  (lxr);      lxr     = NULL;
		//input   ->close (input);    input   = NULL;
	return 0;
}
