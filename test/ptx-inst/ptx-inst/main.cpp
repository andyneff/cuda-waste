#include <stdio.h>
#include <iostream>
#include <cuda.h>

void Test(int x, char * s)
{
	int t = x;
	if (t != 0)
	{
		std::cout << "fail " << t << " " << s << "\n";
		std::cout.flush();
		exit(1);
	}
}

#define ALIGN_UP(offset, alignment) (offset) = ((offset) + (alignment) - 1) & ~((alignment) - 1)

int main()
{
	// Instruction-level test of PTX assembly language and emulator.
	// This test should work natively and under emulation.  Many of the
	// instructions tested here stress many poorly documented features
	// of the PTX assembly language.  If the emulator passes these
	// tests, then it can surely pass code that is generated by the
	// nvcc compiler.
	
	Test(cuInit(0), "cuInit");

	int deviceCount = 0;
	Test(cuDeviceGetCount(&deviceCount), "cuDeviceGetCount");

	CUdevice cuDevice = 0;
	Test(cuDeviceGet(&cuDevice, 0), "cuDeviceGet");

	CUcontext cuContext;
	int xxx = cuCtxCreate(&cuContext, 0, cuDevice);

	CUmodule cuModule;
	Test(cuModuleLoad(&cuModule, "inst.ptx"), "cuModuleLoad");

	// Do basic test.  No sense continuing if we cannot complete this
	// test.
	try
	{
		CUfunction proc;
		Test(cuModuleGetFunction(&proc, cuModule, "InstBasic"), "cuModuleGetFunction");

		bool * h_R = (bool*)malloc(sizeof(bool));
		memset(h_R, 0, sizeof(bool));

		CUdeviceptr d_R;
		Test(cuMemAlloc(&d_R, sizeof(bool)), "cuMemAlloc");

		Test(cuMemcpyHtoD(d_R, h_R, sizeof(bool)), "cuMemcpyHtoD");

		int offset = 0;
		void* ptr;
	
		ptr = (void*)(size_t)d_R;
		ALIGN_UP(offset, __alignof(ptr));
		Test(cuParamSetv(proc, offset, &ptr, sizeof(ptr)), "cuParamSetv");
		offset += sizeof(ptr);

		Test(cuParamSetSize(proc, offset), "cuParamSetSize");

		int threadsPerBlock = 1;
		int blocksPerGrid = 1;

		Test(cuFuncSetBlockShape(proc, threadsPerBlock, 1, 1), "cuFuncSetBlockShape");

		Test(cuLaunchGrid(proc, blocksPerGrid, 1), "cuLaunchGrid");

		Test(cuMemcpyDtoH(h_R, d_R, sizeof(bool)), "cuMemcpyDtoH");

		Test(cuMemFree(d_R), "cuMemFree");

		if (h_R[0] == 1)
			std::cout << "Basic test passed.\n";
		else {
			std::cout << "Basic test failed.\n";
			exit(1);
		}

	} catch (...)
	{
		Test(1, "Test crashed.");
	}

	// Do LD, ST, MOV test.
	try
	{
		CUfunction proc;
		Test(cuModuleGetFunction(&proc, cuModule, "InstLSMC"), "cuModuleGetFunction");

		int max = 1000;

		bool * h_R = (bool*)malloc(max * sizeof(bool));
		memset(h_R, 0, max * sizeof(bool));

		CUdeviceptr d_R;
		Test(cuMemAlloc(&d_R, max * sizeof(bool)), "cuMemAlloc");

		Test(cuMemcpyHtoD(d_R, h_R, sizeof(int)), "cuMemcpyHtoD");

		CUdeviceptr d_N;
		int h_N = 0;
		Test(cuMemAlloc(&d_N, sizeof(int)), "cuMemAlloc");

		Test(cuMemcpyHtoD(d_N, &h_N, sizeof(int)), "cuMemcpyHtoD");

		int offset = 0;
		void* ptr;
		
		ptr = (void*)(size_t)d_R;
		ALIGN_UP(offset, __alignof(ptr));
		Test(cuParamSetv(proc, offset, &ptr, sizeof(ptr)), "cuParamSetv");
		offset += sizeof(ptr);
		
		ptr = (void*)(size_t)d_N;
		ALIGN_UP(offset, __alignof(ptr));
		Test(cuParamSetv(proc, offset, &ptr, sizeof(ptr)), "cuParamSetv");
		offset += sizeof(ptr);
		
		Test(cuParamSetSize(proc, offset), "cuParamSetSize");

		int threadsPerBlock = 1;
		int blocksPerGrid = 1;

		Test(cuFuncSetBlockShape(proc, threadsPerBlock, 1, 1), "cuFuncSetBlockShape");

		Test(cuLaunchGrid(proc, blocksPerGrid, 1), "cuLaunchGrid");

		Test(cuMemcpyDtoH(h_R, d_R, max * sizeof(bool)), "cuMemcpyDtoH");

		Test(cuMemcpyDtoH(&h_N, d_N, sizeof(int)), "cuMemcpyDtoH");

		Test(cuMemFree(d_R), "cuMemFree");

		Test(cuMemFree(d_N), "cuMemFree");

		bool failed = false;
		for (int i = 0; i < h_N; ++i)
		{
			if (h_R[i] == 0)
			{
				failed = true;
				std::cout << "\nTest " << i << " failed.\n";
				std::cout.flush();
			}
		}
		if (! failed)
			std::cout << "Load/store/move test passed.\n";
		else {
			std::cout << "Load/store/move test failed.\n";
			exit(1);
		}
	}
	catch (...)
	{
		Test(1, "Test crashed.");
	}
	
	return 0;
}
